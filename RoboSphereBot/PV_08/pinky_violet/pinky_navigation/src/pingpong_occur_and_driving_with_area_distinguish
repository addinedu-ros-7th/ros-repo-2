#!/usr/bin/env python3
import math
import rclpy
from rclpy.node import Node
from nav2_msgs.action import NavigateToPose
from rclpy.action import ActionClient
from geometry_msgs.msg import PointStamped
from std_msgs.msg import Bool
import time


class DynamicWaypointNavigator(Node):
    def __init__(self):
        super().__init__('dynamic_waypoint_navigator')

        self.waypoints = [
            {"x": 0.0, "y": 0.0, "theta": 0.0},
            {"x": 0.28, "y": 0.0, "theta": -1.57},
            {"x": 0.28, "y": -1.44, "theta": 0},
            {"x": 1.28, "y": -1.44, "theta": 0},
            {"x": 2.1, "y": -1.44, "theta": 1.57},
            {"x": 2.1, "y": -0.85, "theta": -1.57},
            {"x": 0.28, "y": -0.85, "theta": 1.57},
            {"x": 0.28, "y": 0.0, "theta": 3.14},
            {"x": 0.0, "y": 0.0, "theta": 0.0}
        ]
        self.current_waypoint_index = 0
        self.robot_stopped = False
        self.cooldown_start_time = None
        self.cooldown_time = 5.0  

        self.previous_ball_coords = None
        self.stable_coords_time = None
        self.start_wait_time = None
        self.stability_threshold = 5.0  
        self.max_coord_deviation = 0.1  

        self.last_ping_pong_time = time.time()  # ✅ 마지막으로 탁구공이 감지된 시간
        self.max_wait_time = 5.0  # ✅ 탁구공 감지가 없으면 5초 후 원래 웨이포인트로 이동

        self.excluded_zones = [
            {"x_min": 0.41, "x_max": 0.97, "y_min": -1.4, "y_max": -1.06},  # ❗ 영역 1
            {"x_min": 1.76, "x_max": 2.21, "y_min": -0.69, "y_max": -0.38}  # ❗ 영역 2
        ]

        self.reached_goal_pub = self.create_publisher(Bool, '/reached_goal', 10)
        self.create_subscription(PointStamped, '/ping_pong_map_coords', self.ping_pong_callback, 10)

        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')
        self.get_logger().info("Waiting for action server...")
        self.nav_client.wait_for_server()
        self.get_logger().info("Action server ready. Starting navigation...")

        self.send_goal()

        # ✅ 주기적으로 탁구공 감지 여부를 확인하는 타이머 추가
        self.create_timer(10.0, self.check_ping_pong_timeout)

    def ping_pong_callback(self, msg):
        """탁구공 감지 및 안정적인 좌표 확인 후 웨이포인트 추가"""
        ball_x, ball_y = msg.point.x, msg.point.y

        # 쿨다운 중이면 무시
        if self.cooldown_start_time and time.time() - self.cooldown_start_time < self.cooldown_time:
            self.get_logger().info("Cooldown active. Ignoring new ping pong coordinates.")
            return

        # 로봇이 이동 중이면 즉시 정지
        if not self.robot_stopped:
            self.stop_robot()
            self.robot_stopped = True
            self.start_wait_time = time.time()
            self.stable_coords_time = time.time()
            self.previous_ball_coords = (ball_x, ball_y)
            self.get_logger().info("Ping pong ball detected. Stopping to check stability.")
            return

        # 좌표 안정성 확인
        prev_x, prev_y = self.previous_ball_coords
        deviation = math.sqrt((ball_x - prev_x) ** 2 + (ball_y - prev_y) ** 2)

        if deviation <= self.max_coord_deviation:
            if time.time() - self.stable_coords_time >= self.stability_threshold:
                self.get_logger().info(f"Ping pong ball is stable. Adding waypoint at x={ball_x}, y={ball_y}.")

                # ✅ 제외 영역 검사 시작 로그 추가
                self.get_logger().info("Checking if the ball is in an excluded zone...")

                if self.is_excluded_zone(ball_x, ball_y):
                    self.get_logger().warn("Ball is in an excluded zone. Ignoring. Exiting ping_pong_callback function.")
                    self.robot_stopped = False

                    # ✅ 웨이포인트 이동을 확실하게 실행
                    self.get_logger().info("Resuming navigation to original waypoint.")

                    # ✅ 다시 감지하지 않도록 쿨다운 시작 (5초 동안 감지 무시)
                    self.cooldown_start_time = time.time()
                    self.get_logger().info(f"Cooldown started at {self.cooldown_start_time}, ignoring new detections for {self.cooldown_time} seconds.")

                    self.send_goal()  # 기존 웨이포인트로 이동하도록 보장
                    return

                # ✅ 제외 영역이 아닐 경우 웨이포인트 추가
                self.get_logger().info("Ball is not in an excluded zone. Adding waypoint...")
                self.add_dynamic_waypoint(ball_x, ball_y)

                self.robot_stopped = False
                self.cooldown_start_time = time.time()
                self.send_goal()
                return
        else:
            self.stable_coords_time = time.time()  # 변동 발생 시 안정성 체크 초기화
            self.previous_ball_coords = (ball_x, ball_y)
            self.get_logger().info("Ping pong ball coordinates are unstable. Resetting stability check.")

        # 안정성이 5초 동안 유지되지 않으면 원래 경로 유지
        if time.time() - self.start_wait_time >= self.stability_threshold:
            self.get_logger().warn("Stability check timed out. Resuming original navigation.")
            self.robot_stopped = False
            self.send_goal()


    def is_excluded_zone(self, x, y):
        """✅ 좌표가 여러 개의 제외 영역 중 하나에 포함되는지 확인"""
        for zone in self.excluded_zones:
            if zone["x_min"] <= x <= zone["x_max"] and zone["y_min"] <= y <= zone["y_max"]:
                return True  # 제외 영역에 포함됨
        return False  # 제외 영역이 아님

    def check_ping_pong_timeout(self):
        """✅ 일정 시간 동안 탁구공 감지가 없으면 원래 웨이포인트로 이동"""
        if time.time() - self.last_ping_pong_time >= self.max_wait_time:
            self.get_logger().warn("No ping pong ball detected for a while. Resuming original navigation.")
            if self.robot_stopped:
                self.robot_stopped = False
                self.send_goal()  # ✅ 원래 웨이포인트로 복귀

    def add_dynamic_waypoint(self, x, y):
        """현재 목표 웨이포인트 앞에 새로운 웨이포인트 삽입"""
        dynamic_waypoint = {"x": x, "y": y, "theta": 0.0}
        
        # 현재 이동 중인 웨이포인트 앞에 삽입
        self.waypoints.insert(self.current_waypoint_index, dynamic_waypoint)
        
        self.get_logger().info(f"Dynamic waypoint added at x={x}, y={y}. Moving to the ball first.")

    def stop_robot(self):
        """로봇을 정지시키고 현재 목표 취소"""
        self.get_logger().info("Stopping the robot to check ping pong ball stability.")
        if hasattr(self, "current_goal_handle") and self.current_goal_handle:
            cancel_future = self.current_goal_handle.cancel_goal_async()
            cancel_future.add_done_callback(self.goal_cancel_callback)

    def goal_cancel_callback(self, future):
        """목표 취소 콜백"""
        try:
            cancel_response = future.result()
            if cancel_response:
                self.get_logger().info("Goal cancellation processed.")
            else:
                self.get_logger().warn("Goal cancellation failed or no response received.")
        except Exception as e:
            self.get_logger().error(f"Error in cancel callback: {e}")

        self.send_goal()

    def send_goal(self):
        """웨이포인트 이동"""
        if self.robot_stopped:  # 로봇이 멈춘 상태라면 목표를 설정하지 않음
            return

        if self.current_waypoint_index >= len(self.waypoints):
            self.get_logger().info("Reached the final waypoint.")
            self.reached_goal_pub.publish(Bool(data=True))
            self.cooldown_start_time = None
            return

        waypoint = self.waypoints[self.current_waypoint_index]

        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        goal_msg.pose.pose.position.x = waypoint["x"]
        goal_msg.pose.pose.position.y = waypoint["y"]

        self.get_logger().info(f"Navigating to waypoint {self.current_waypoint_index + 1}/{len(self.waypoints)}: "
                               f"x={waypoint['x']}, y={waypoint['y']}")
        send_goal_future = self.nav_client.send_goal_async(goal_msg)
        send_goal_future.add_done_callback(self.goal_sent_callback)

    def goal_sent_callback(self, future):
        """목표가 정상적으로 전송되었는지 확인하는 콜백"""
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().error("Goal was rejected by the server.")
            return
        self.get_logger().info("Goal accepted by the server.")
        self.current_goal_handle = goal_handle

        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.result_callback)

    def result_callback(self, future):
        """목표 도달 후 다음 웨이포인트로 이동"""
        result = future.result()
        if result.status == 4:  # STATUS_SUCCEEDED
            self.get_logger().info(f"Reached waypoint {self.current_waypoint_index + 1}/{len(self.waypoints)}.")
            self.current_waypoint_index += 1
            self.retry_count = 0  # 실패 횟수 초기화
            self.send_goal()
        else:
            self.get_logger().error("Failed to reach waypoint. Retrying current waypoint.")

            self.send_goal()

def main(args=None):
    """ROS 2 노드를 실행하는 메인 함수"""
    rclpy.init(args=args)
    node = DynamicWaypointNavigator()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
